# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?
In the console.rb file when we save property1, property2 & property3 using Property.new

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?
In the property.rb file when we create the method save

Q3. In `console.rb`, which lines modify the database?
The lines where we call the methods property1.save, property1.update and property2.delete

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?
We want the database to assign the next available number and not have the need to check the database manually every time to
 find the next available number

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?
In property.rb and in the save function we return every thing after sending it all the other information.  This includes the ID
where we can then update this instances variables with the new id.  
RETURNING * returns all the variables back
@id = db.exec_prepared("save", values)[0]['id'].to_i saves the id back to the instance


Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?
When we first create the instance it doesn't have an id so this allows up to bypass passing in a value for this variable but we need to have a holder for the id for when the database returns it's value.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
The instance methods are for when you are calling it on an instance it property1.save.  A class method is for when you need
to do something but need access to the full database like trying to find something by id or address.  You don't know what instance it is so you go through the full list.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?
It returns it as a hash in an array, we need to get the id from the hash and use the first item [0], from here we also
make sure it is an integer by performing a .to_i

Q9. Why do we use prepared statements when performing database operations?
so the database knows to expect values and not a SQL command.  This helps prevent SQL injection

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?
find_by_id takes in an integer and find_by_address takes in a string

Q11. What are their return values?
They return an array
